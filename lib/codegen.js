/**
 * OCP API Codegen - Core Library
 * Open Config Protocol - Node.js SDK Generator
 */

const fs = require('fs');
const path = require('path');

class OCPCodegen {
  constructor(schemaPath) {
    this.schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
    this.name = this.schema.meta.name;
    this.pascalName = this.toPascalCase(this.name);
  }

  toPascalCase(str) {
    return str.replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase());
  }

  toCamelCase(str) {
    return str.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
  }

  toTsType(def) {
    if (typeof def === 'string') return 'string';

    const typeMap = {
      'string': 'string',
      'integer': 'number',
      'number': 'number',
      'boolean': 'boolean',
      'array': 'unknown[]',
      'object': 'Record<string, unknown>'
    };

    return typeMap[def.type] || 'unknown';
  }

  generateTypes() {
    const lines = [];

    lines.push('// Auto-generated by OCP Codegen');
    lines.push('// Open Config Protocol - https://github.com/ocp-api-codegen-node');
    lines.push('// Do not edit manually');
    lines.push('');

    // Client config type
    lines.push(`export interface ${this.pascalName}Config {`);

    const urlPlaceholders = this.schema.meta.base_url.match(/\{(\w+)\}/g) || [];
    for (const placeholder of urlPlaceholders) {
      const name = placeholder.slice(1, -1);
      lines.push(`  ${name}: string;`);
    }

    const auth = this.schema.meta.auth;
    if (auth?.type === 'oauth2_client_credentials') {
      lines.push('  clientId: string;');
      lines.push('  clientSecret: string;');
    } else if (auth?.type === 'api_key') {
      lines.push('  apiKey: string;');
    } else if (auth?.type === 'bearer') {
      lines.push('  token: string;');
    }

    lines.push('  timeout?: number;');
    lines.push('}');
    lines.push('');

    // Generate param types for each endpoint
    const endpoints = this.schema.endpoints || {};
    for (const [groupName, group] of Object.entries(endpoints)) {
      for (const [endpointName, endpoint] of Object.entries(group)) {
        if (!endpoint.method) continue;

        const typeName = `${this.pascalName}${this.toPascalCase(groupName)}${this.toPascalCase(endpointName)}`;

        const hasParams = endpoint.params || endpoint.query || endpoint.body?.fields;
        if (hasParams) {
          lines.push(`export interface ${typeName}Params {`);

          if (endpoint.params) {
            for (const [name, def] of Object.entries(endpoint.params)) {
              const tsType = this.toTsType(def);
              const optional = def.required ? '' : '?';
              lines.push(`  ${name}${optional}: ${tsType};`);
            }
          }

          if (endpoint.query) {
            for (const [name, def] of Object.entries(endpoint.query)) {
              const tsType = this.toTsType(def);
              const optional = def.required ? '' : '?';
              lines.push(`  ${name}${optional}: ${tsType};`);
            }
          }

          if (endpoint.body?.fields) {
            for (const [name, def] of Object.entries(endpoint.body.fields)) {
              const tsType = this.toTsType(def);
              const optional = def.required ? '' : '?';
              lines.push(`  ${name}${optional}: ${tsType};`);
            }
          }

          lines.push('}');
          lines.push('');
        }
      }
    }

    // Generate response types
    const responseTypes = new Set();
    for (const [groupName, group] of Object.entries(endpoints)) {
      for (const [endpointName, endpoint] of Object.entries(group)) {
        if (endpoint.response?.type) {
          responseTypes.add(endpoint.response.type);
        }
      }
    }

    for (const typeName of responseTypes) {
      lines.push(`export interface ${typeName} {`);
      lines.push('  [key: string]: unknown;');
      lines.push('}');
      lines.push('');
    }

    // Pagination response wrapper
    lines.push(`export interface ${this.pascalName}PaginatedResponse<T> {`);
    lines.push('  data: T[];');
    lines.push('  pagination?: {');
    lines.push('    after_cursor: string | null;');
    lines.push('  };');
    lines.push('}');
    lines.push('');

    // Client interface
    lines.push(`export interface ${this.pascalName}Client {`);
    for (const [groupName, group] of Object.entries(endpoints)) {
      const methods = [];
      for (const [endpointName, endpoint] of Object.entries(group)) {
        if (!endpoint.method) continue;

        const typeName = `${this.pascalName}${this.toPascalCase(groupName)}${this.toPascalCase(endpointName)}`;
        const hasParams = endpoint.params || endpoint.query || endpoint.body?.fields;
        const paramType = hasParams ? `params: ${typeName}Params` : '';

        let returnType = 'void';
        if (endpoint.response) {
          returnType = endpoint.response.type;
          if (endpoint.response.array) {
            returnType = endpoint.pagination
              ? `${this.pascalName}PaginatedResponse<${returnType}>`
              : `${returnType}[]`;
          }
        }

        methods.push(`    ${this.toCamelCase(endpointName)}(${paramType}): Promise<${returnType}>;`);
      }

      if (methods.length > 0) {
        lines.push(`  ${groupName}: {`);
        lines.push(methods.join('\n'));
        lines.push('  };');
      }
    }
    lines.push('}');
    lines.push('');

    lines.push(`export declare function create${this.pascalName}Client(config: ${this.pascalName}Config): ${this.pascalName}Client;`);
    lines.push('');

    return lines.join('\n');
  }

  generateClient() {
    const lines = [];

    lines.push('// Auto-generated by OCP Codegen');
    lines.push('// Open Config Protocol - https://github.com/ocp-api-codegen-node');
    lines.push('// Do not edit manually');
    lines.push('');
    lines.push("const https = require('https');");
    lines.push("const http = require('http');");
    lines.push('');

    // Embed schema
    lines.push(`const SCHEMA = ${JSON.stringify(this.schema, null, 2)};`);
    lines.push('');

    // HTTP request helper
    lines.push(`
function request(url, options, body) {
  return new Promise((resolve, reject) => {
    const parsedUrl = new URL(url);
    const client = parsedUrl.protocol === 'https:' ? https : http;

    const req = client.request(url, options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const parsed = data ? JSON.parse(data) : null;
          if (res.statusCode >= 400) {
            const err = new Error(parsed?.message || \`HTTP \${res.statusCode}\`);
            err.status = res.statusCode;
            err.response = parsed;
            reject(err);
          } else {
            resolve(parsed);
          }
        } catch (e) {
          reject(new Error(\`Failed to parse response: \${data}\`));
        }
      });
    });

    req.on('error', reject);
    req.setTimeout(options.timeout || 30000, () => {
      req.destroy();
      reject(new Error('Request timeout'));
    });

    if (body) {
      req.write(JSON.stringify(body));
    }
    req.end();
  });
}
`);

    // Token management for OAuth2
    if (this.schema.meta.auth?.type === 'oauth2_client_credentials') {
      lines.push(`
class TokenManager {
  constructor(baseUrl, tokenEndpoint, clientId, clientSecret) {
    this.baseUrl = baseUrl;
    this.tokenEndpoint = tokenEndpoint;
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.token = null;
    this.expiresAt = 0;
  }

  async getToken() {
    if (this.token && Date.now() < this.expiresAt - 60000) {
      return this.token;
    }

    const url = this.baseUrl + this.tokenEndpoint;
    const auth = Buffer.from(\`\${this.clientId}:\${this.clientSecret}\`).toString('base64');

    const response = await request(url, {
      method: 'POST',
      headers: {
        'Authorization': \`Basic \${auth}\`,
        'Content-Type': 'application/json'
      }
    }, { grant_type: 'client_credentials' });

    this.token = response.access_token;
    this.expiresAt = Date.now() + (response.expires_in * 1000);

    return this.token;
  }
}
`);
    }

    // Helpers
    lines.push(`
function buildPath(template, params) {
  let path = template;
  for (const [key, value] of Object.entries(params || {})) {
    path = path.replace(\`:\${key}\`, encodeURIComponent(value));
  }
  return path;
}

function buildQueryString(params) {
  const query = new URLSearchParams();
  for (const [key, value] of Object.entries(params || {})) {
    if (value !== undefined && value !== null) {
      query.append(key, value);
    }
  }
  const str = query.toString();
  return str ? \`?\${str}\` : '';
}
`);

    // Main factory function
    lines.push(`
function create${this.pascalName}Client(config) {
  let baseUrl = SCHEMA.meta.base_url;
  const urlParams = baseUrl.match(/\\{(\\w+)\\}/g) || [];
  for (const param of urlParams) {
    const key = param.slice(1, -1);
    if (!config[key]) throw new Error(\`Missing required config: \${key}\`);
    baseUrl = baseUrl.replace(param, config[key]);
  }
`);

    if (this.schema.meta.auth?.type === 'oauth2_client_credentials') {
      lines.push(`
  const tokenManager = new TokenManager(
    baseUrl,
    SCHEMA.meta.auth.token_endpoint,
    config.clientId,
    config.clientSecret
  );

  async function callEndpoint(endpoint, params = {}) {
    const token = await tokenManager.getToken();
`);
    } else if (this.schema.meta.auth?.type === 'api_key') {
      lines.push(`
  async function callEndpoint(endpoint, params = {}) {
    const token = config.apiKey;
`);
    } else if (this.schema.meta.auth?.type === 'bearer') {
      lines.push(`
  async function callEndpoint(endpoint, params = {}) {
    const token = config.token;
`);
    } else {
      lines.push(`
  async function callEndpoint(endpoint, params = {}) {
`);
    }

    lines.push(`
    const pathParams = {};
    const queryParams = {};
    const bodyParams = {};

    const pathParamNames = (endpoint.path.match(/:(\\w+)/g) || []).map(p => p.slice(1));

    for (const [key, value] of Object.entries(params)) {
      if (pathParamNames.includes(key)) {
        pathParams[key] = value;
      } else if (endpoint.query && key in endpoint.query) {
        queryParams[key] = value;
      } else {
        bodyParams[key] = value;
      }
    }

    const path = buildPath(endpoint.path, pathParams);
    const queryString = buildQueryString(queryParams);
    const url = baseUrl + path + queryString;

    const hasBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method);
    const body = hasBody && Object.keys(bodyParams).length > 0 ? bodyParams : null;
    const finalBody = endpoint.body?.type === 'array' && Array.isArray(params) ? params : body;

    const headers = {
      'Content-Type': 'application/json'
    };
`);

    if (this.schema.meta.auth?.type) {
      lines.push(`    headers['Authorization'] = \`Bearer \${token}\`;`);
    }

    lines.push(`
    return request(url, {
      method: endpoint.method,
      headers,
      timeout: config.timeout || 30000
    }, finalBody);
  }
`);

    // Build client object
    lines.push('  return {');

    const endpoints = this.schema.endpoints || {};
    const groupEntries = Object.entries(endpoints).filter(([_, group]) => {
      return Object.values(group).some(e => e.method);
    });

    for (let i = 0; i < groupEntries.length; i++) {
      const [groupName, group] = groupEntries[i];
      const endpointEntries = Object.entries(group).filter(([_, e]) => e.method);

      lines.push(`    ${groupName}: {`);

      for (let j = 0; j < endpointEntries.length; j++) {
        const [endpointName, endpoint] = endpointEntries[j];
        const camelName = this.toCamelCase(endpointName);
        const comma = j < endpointEntries.length - 1 ? ',' : '';

        lines.push(`      ${camelName}: (params) => callEndpoint(${JSON.stringify(endpoint)}, params)${comma}`);
      }

      const groupComma = i < groupEntries.length - 1 ? ',' : '';
      lines.push(`    }${groupComma}`);
    }

    lines.push('  };');
    lines.push('}');
    lines.push('');

    lines.push(`module.exports = { create${this.pascalName}Client };`);

    return lines.join('\n');
  }

  generate(outputDir = '.') {
    const types = this.generateTypes();
    const client = this.generateClient();

    fs.writeFileSync(path.join(outputDir, 'index.d.ts'), types);
    fs.writeFileSync(path.join(outputDir, 'index.js'), client);

    console.log(`Generated SDK for ${this.name}:`);
    console.log(`  - index.d.ts (TypeScript types)`);
    console.log(`  - index.js (Runtime client)`);
  }
}

module.exports = { OCPCodegen };
